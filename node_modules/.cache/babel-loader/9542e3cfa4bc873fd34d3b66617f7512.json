{"ast":null,"code":"import _classCallCheck from \"D:\\\\MyProject\\\\scrollTable\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\MyProject\\\\scrollTable\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/* Forked from react-virtualized ðŸ’– */\nimport { ALIGNMENT } from \"./constants\";\n\nvar SizeAndPositionManager =\n/*#__PURE__*/\nfunction () {\n  function SizeAndPositionManager(_ref) {\n    var itemCount = _ref.itemCount,\n        itemSizeGetter = _ref.itemSizeGetter,\n        estimatedItemSize = _ref.estimatedItemSize;\n\n    _classCallCheck(this, SizeAndPositionManager);\n\n    this.itemSizeGetter = void 0;\n    this.itemCount = void 0;\n    this.estimatedItemSize = void 0;\n    this.lastMeasuredIndex = void 0;\n    this.itemSizeAndPositionData = void 0;\n    this.itemSizeGetter = itemSizeGetter;\n    this.itemCount = itemCount;\n    this.estimatedItemSize = estimatedItemSize; // Cache of size and position data for items, mapped by item index.\n\n    this.itemSizeAndPositionData = {}; // Measurements for items up to this index can be trusted; items afterward should be estimated.\n\n    this.lastMeasuredIndex = -1;\n  }\n\n  _createClass(SizeAndPositionManager, [{\n    key: \"updateConfig\",\n    value: function updateConfig(_ref2) {\n      var itemCount = _ref2.itemCount,\n          itemSizeGetter = _ref2.itemSizeGetter,\n          estimatedItemSize = _ref2.estimatedItemSize;\n\n      if (itemCount != null) {\n        this.itemCount = itemCount;\n      }\n\n      if (estimatedItemSize != null) {\n        this.estimatedItemSize = estimatedItemSize;\n      }\n\n      if (itemSizeGetter != null) {\n        this.itemSizeGetter = itemSizeGetter;\n      }\n    }\n  }, {\n    key: \"getLastMeasuredIndex\",\n    value: function getLastMeasuredIndex() {\n      return this.lastMeasuredIndex;\n    }\n    /**\r\n     * This method returns the size and position for the item at the specified index.\r\n     * It just-in-time calculates (or used cached values) for items leading up to the index.\r\n     */\n\n  }, {\n    key: \"getSizeAndPositionForIndex\",\n    value: function getSizeAndPositionForIndex(index) {\n      if (index < 0 || index >= this.itemCount) {\n        throw Error(\"Requested index \".concat(index, \" is outside of range 0..\").concat(this.itemCount));\n      }\n\n      if (index > this.lastMeasuredIndex) {\n        var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n        var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n\n        for (var i = this.lastMeasuredIndex + 1; i <= index; i++) {\n          var size = this.itemSizeGetter(i);\n\n          if (size == null || isNaN(size)) {\n            throw Error(\"Invalid size returned for index \".concat(i, \" of value \").concat(size));\n          }\n\n          this.itemSizeAndPositionData[i] = {\n            offset: offset,\n            size: size\n          };\n          offset += size;\n        }\n\n        this.lastMeasuredIndex = index;\n      }\n\n      return this.itemSizeAndPositionData[index];\n    }\n  }, {\n    key: \"getSizeAndPositionOfLastMeasuredItem\",\n    value: function getSizeAndPositionOfLastMeasuredItem() {\n      return this.lastMeasuredIndex >= 0 ? this.itemSizeAndPositionData[this.lastMeasuredIndex] : {\n        offset: 0,\n        size: 0\n      };\n    }\n    /**\r\n     * Total size of all items being measured.\r\n     * This value will be completedly estimated initially.\r\n     * As items as measured the estimate will be updated.\r\n     */\n\n  }, {\n    key: \"getTotalSize\",\n    value: function getTotalSize() {\n      var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize;\n    }\n    /**\r\n     * Determines a new offset that ensures a certain item is visible, given the alignment.\r\n     *\r\n     * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\r\n     * @param containerSize Size (width or height) of the container viewport\r\n     * @return Offset to use to ensure the specified item is visible\r\n     */\n\n  }, {\n    key: \"getUpdatedOffsetForIndex\",\n    value: function getUpdatedOffsetForIndex(_ref3) {\n      var _ref3$align = _ref3.align,\n          align = _ref3$align === void 0 ? ALIGNMENT.START : _ref3$align,\n          containerSize = _ref3.containerSize,\n          currentOffset = _ref3.currentOffset,\n          targetIndex = _ref3.targetIndex;\n\n      if (containerSize <= 0) {\n        return 0;\n      }\n\n      var datum = this.getSizeAndPositionForIndex(targetIndex);\n      var maxOffset = datum.offset;\n      var minOffset = maxOffset - containerSize + datum.size;\n      var idealOffset;\n\n      switch (align) {\n        case ALIGNMENT.END:\n          idealOffset = minOffset;\n          break;\n\n        case ALIGNMENT.CENTER:\n          idealOffset = maxOffset - (containerSize - datum.size) / 2;\n          break;\n\n        case ALIGNMENT.START:\n          idealOffset = maxOffset;\n          break;\n\n        default:\n          idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n      }\n\n      var totalSize = this.getTotalSize();\n      return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n    }\n  }, {\n    key: \"getVisibleRange\",\n    value: function getVisibleRange(_ref4) {\n      var containerSize = _ref4.containerSize,\n          offset = _ref4.offset,\n          overscanCount = _ref4.overscanCount;\n      var totalSize = this.getTotalSize();\n\n      if (totalSize === 0) {\n        return {};\n      }\n\n      var maxOffset = offset + containerSize;\n      var start = this.findNearestItem(offset);\n\n      if (typeof start === \"undefined\") {\n        throw Error(\"Invalid offset \".concat(offset, \" specified\"));\n      }\n\n      var datum = this.getSizeAndPositionForIndex(start);\n      offset = datum.offset + datum.size;\n      var stop = start;\n\n      while (offset < maxOffset && stop < this.itemCount - 1) {\n        stop++;\n        offset += this.getSizeAndPositionForIndex(stop).size;\n      }\n\n      if (overscanCount) {\n        start = Math.max(0, start - overscanCount);\n        stop = Math.min(stop + overscanCount, this.itemCount - 1);\n      }\n\n      return {\n        start: start,\n        stop: stop\n      };\n    }\n    /**\r\n     * Clear all cached values for items after the specified index.\r\n     * This method should be called for any item that has changed its size.\r\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\r\n     */\n\n  }, {\n    key: \"resetItem\",\n    value: function resetItem(index) {\n      this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\n    }\n    /**\r\n     * Searches for the item (index) nearest the specified offset.\r\n     *\r\n     * If no exact match is found the next lowest item index will be returned.\r\n     * This allows partially visible items (with offsets just before/above the fold) to be visible.\r\n     */\n\n  }, {\n    key: \"findNearestItem\",\n    value: function findNearestItem(offset) {\n      if (isNaN(offset)) {\n        throw Error(\"Invalid offset \".concat(offset, \" specified\"));\n      } // Our search algorithms find the nearest match at or below the specified offset.\n      // So make sure the offset is at least 0 or no match will be found.\n\n\n      offset = Math.max(0, offset);\n      var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      var lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\n\n      if (lastMeasuredSizeAndPosition.offset >= offset) {\n        // If we've already measured items within this range just use a binary search as it's faster.\n        return this.binarySearch({\n          high: lastMeasuredIndex,\n          low: 0,\n          offset: offset\n        });\n      } else {\n        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n        // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n        // The overall complexity for this approach is O(log n).\n        return this.exponentialSearch({\n          index: lastMeasuredIndex,\n          offset: offset\n        });\n      }\n    }\n  }, {\n    key: \"binarySearch\",\n    value: function binarySearch(_ref5) {\n      var low = _ref5.low,\n          high = _ref5.high,\n          offset = _ref5.offset;\n      var middle = 0;\n      var currentOffset = 0;\n\n      while (low <= high) {\n        middle = low + Math.floor((high - low) / 2);\n        currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n        if (currentOffset === offset) {\n          return middle;\n        } else if (currentOffset < offset) {\n          low = middle + 1;\n        } else if (currentOffset > offset) {\n          high = middle - 1;\n        }\n      }\n\n      if (low > 0) {\n        return low - 1;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"exponentialSearch\",\n    value: function exponentialSearch(_ref6) {\n      var index = _ref6.index,\n          offset = _ref6.offset;\n      var interval = 1;\n\n      while (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n        index += interval;\n        interval *= 2;\n      }\n\n      return this.binarySearch({\n        high: Math.min(index, this.itemCount - 1),\n        low: Math.floor(index / 2),\n        offset: offset\n      });\n    }\n  }]);\n\n  return SizeAndPositionManager;\n}();\n\nexport { SizeAndPositionManager as default };","map":{"version":3,"sources":["D:/MyProject/scrollTable/src/components/virtualList/SizeAndPositionManager.ts"],"names":["ALIGNMENT","SizeAndPositionManager","itemCount","itemSizeGetter","estimatedItemSize","lastMeasuredIndex","itemSizeAndPositionData","index","Error","lastMeasuredSizeAndPosition","getSizeAndPositionOfLastMeasuredItem","offset","size","i","isNaN","align","START","containerSize","currentOffset","targetIndex","datum","getSizeAndPositionForIndex","maxOffset","minOffset","idealOffset","END","CENTER","Math","max","min","totalSize","getTotalSize","overscanCount","start","findNearestItem","stop","binarySearch","high","low","exponentialSearch","middle","floor","interval"],"mappings":"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","sourcesContent":["/* Forked from react-virtualized ðŸ’– */\r\nimport { ALIGNMENT } from \"./constants\";\r\n\r\nexport type ItemSizeGetter = (index: number) => number;\r\nexport type ItemSize = number | number[] | ItemSizeGetter;\r\n\r\nexport interface SizeAndPosition {\r\n  size: number;\r\n  offset: number;\r\n}\r\n\r\ninterface SizeAndPositionData {\r\n  [id: number]: SizeAndPosition;\r\n}\r\n\r\nexport interface Options {\r\n  itemCount: number;\r\n  itemSizeGetter: ItemSizeGetter;\r\n  estimatedItemSize: number;\r\n}\r\n\r\nexport default class SizeAndPositionManager {\r\n  private itemSizeGetter: ItemSizeGetter;\r\n  private itemCount: number;\r\n  private estimatedItemSize: number;\r\n  private lastMeasuredIndex: number;\r\n  private itemSizeAndPositionData: SizeAndPositionData;\r\n\r\n  constructor({ itemCount, itemSizeGetter, estimatedItemSize }: Options) {\r\n    this.itemSizeGetter = itemSizeGetter;\r\n    this.itemCount = itemCount;\r\n    this.estimatedItemSize = estimatedItemSize;\r\n\r\n    // Cache of size and position data for items, mapped by item index.\r\n    this.itemSizeAndPositionData = {};\r\n\r\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\r\n    this.lastMeasuredIndex = -1;\r\n  }\r\n\r\n  updateConfig({\r\n    itemCount,\r\n    itemSizeGetter,\r\n    estimatedItemSize\r\n  }: Partial<Options>) {\r\n    if (itemCount != null) {\r\n      this.itemCount = itemCount;\r\n    }\r\n\r\n    if (estimatedItemSize != null) {\r\n      this.estimatedItemSize = estimatedItemSize;\r\n    }\r\n\r\n    if (itemSizeGetter != null) {\r\n      this.itemSizeGetter = itemSizeGetter;\r\n    }\r\n  }\r\n\r\n  getLastMeasuredIndex() {\r\n    return this.lastMeasuredIndex;\r\n  }\r\n\r\n  /**\r\n   * This method returns the size and position for the item at the specified index.\r\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\r\n   */\r\n  getSizeAndPositionForIndex(index: number) {\r\n    if (index < 0 || index >= this.itemCount) {\r\n      throw Error(\r\n        `Requested index ${index} is outside of range 0..${this.itemCount}`\r\n      );\r\n    }\r\n\r\n    if (index > this.lastMeasuredIndex) {\r\n      const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\r\n      let offset =\r\n        lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\r\n\r\n      for (let i = this.lastMeasuredIndex + 1; i <= index; i++) {\r\n        const size = this.itemSizeGetter(i);\r\n\r\n        if (size == null || isNaN(size)) {\r\n          throw Error(`Invalid size returned for index ${i} of value ${size}`);\r\n        }\r\n\r\n        this.itemSizeAndPositionData[i] = {\r\n          offset,\r\n          size\r\n        };\r\n\r\n        offset += size;\r\n      }\r\n\r\n      this.lastMeasuredIndex = index;\r\n    }\r\n\r\n    return this.itemSizeAndPositionData[index];\r\n  }\r\n\r\n  getSizeAndPositionOfLastMeasuredItem() {\r\n    return this.lastMeasuredIndex >= 0\r\n      ? this.itemSizeAndPositionData[this.lastMeasuredIndex]\r\n      : { offset: 0, size: 0 };\r\n  }\r\n\r\n  /**\r\n   * Total size of all items being measured.\r\n   * This value will be completedly estimated initially.\r\n   * As items as measured the estimate will be updated.\r\n   */\r\n  getTotalSize(): number {\r\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\r\n\r\n    return (\r\n      lastMeasuredSizeAndPosition.offset +\r\n      lastMeasuredSizeAndPosition.size +\r\n      (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\r\n   *\r\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\r\n   * @param containerSize Size (width or height) of the container viewport\r\n   * @return Offset to use to ensure the specified item is visible\r\n   */\r\n  getUpdatedOffsetForIndex({\r\n    align = ALIGNMENT.START,\r\n    containerSize,\r\n    currentOffset,\r\n    targetIndex\r\n  }: {\r\n    align: ALIGNMENT | undefined;\r\n    containerSize: number;\r\n    currentOffset: number;\r\n    targetIndex: number;\r\n  }): number {\r\n    if (containerSize <= 0) {\r\n      return 0;\r\n    }\r\n\r\n    const datum = this.getSizeAndPositionForIndex(targetIndex);\r\n    const maxOffset = datum.offset;\r\n    const minOffset = maxOffset - containerSize + datum.size;\r\n\r\n    let idealOffset;\r\n\r\n    switch (align) {\r\n      case ALIGNMENT.END:\r\n        idealOffset = minOffset;\r\n        break;\r\n      case ALIGNMENT.CENTER:\r\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\r\n        break;\r\n      case ALIGNMENT.START:\r\n        idealOffset = maxOffset;\r\n        break;\r\n      default:\r\n        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\r\n    }\r\n\r\n    const totalSize = this.getTotalSize();\r\n\r\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\r\n  }\r\n\r\n  getVisibleRange({\r\n    containerSize,\r\n    offset,\r\n    overscanCount\r\n  }: {\r\n    containerSize: number;\r\n    offset: number;\r\n    overscanCount: number;\r\n  }): { start?: number; stop?: number } {\r\n    const totalSize = this.getTotalSize();\r\n\r\n    if (totalSize === 0) {\r\n      return {};\r\n    }\r\n\r\n    const maxOffset = offset + containerSize;\r\n    let start = this.findNearestItem(offset);\r\n\r\n    if (typeof start === \"undefined\") {\r\n      throw Error(`Invalid offset ${offset} specified`);\r\n    }\r\n\r\n    const datum = this.getSizeAndPositionForIndex(start);\r\n    offset = datum.offset + datum.size;\r\n\r\n    let stop = start;\r\n\r\n    while (offset < maxOffset && stop < this.itemCount - 1) {\r\n      stop++;\r\n      offset += this.getSizeAndPositionForIndex(stop).size;\r\n    }\r\n\r\n    if (overscanCount) {\r\n      start = Math.max(0, start - overscanCount);\r\n      stop = Math.min(stop + overscanCount, this.itemCount - 1);\r\n    }\r\n\r\n    return {\r\n      start,\r\n      stop\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all cached values for items after the specified index.\r\n   * This method should be called for any item that has changed its size.\r\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\r\n   */\r\n  resetItem(index: number) {\r\n    this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\r\n  }\r\n\r\n  /**\r\n   * Searches for the item (index) nearest the specified offset.\r\n   *\r\n   * If no exact match is found the next lowest item index will be returned.\r\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\r\n   */\r\n  findNearestItem(offset: number) {\r\n    if (isNaN(offset)) {\r\n      throw Error(`Invalid offset ${offset} specified`);\r\n    }\r\n\r\n    // Our search algorithms find the nearest match at or below the specified offset.\r\n    // So make sure the offset is at least 0 or no match will be found.\r\n    offset = Math.max(0, offset);\r\n\r\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\r\n    const lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\r\n\r\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\r\n      // If we've already measured items within this range just use a binary search as it's faster.\r\n      return this.binarySearch({\r\n        high: lastMeasuredIndex,\r\n        low: 0,\r\n        offset\r\n      });\r\n    } else {\r\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\r\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\r\n      // The overall complexity for this approach is O(log n).\r\n      return this.exponentialSearch({\r\n        index: lastMeasuredIndex,\r\n        offset\r\n      });\r\n    }\r\n  }\r\n\r\n  private binarySearch({\r\n    low,\r\n    high,\r\n    offset\r\n  }: {\r\n    low: number;\r\n    high: number;\r\n    offset: number;\r\n  }) {\r\n    let middle = 0;\r\n    let currentOffset = 0;\r\n\r\n    while (low <= high) {\r\n      middle = low + Math.floor((high - low) / 2);\r\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\r\n\r\n      if (currentOffset === offset) {\r\n        return middle;\r\n      } else if (currentOffset < offset) {\r\n        low = middle + 1;\r\n      } else if (currentOffset > offset) {\r\n        high = middle - 1;\r\n      }\r\n    }\r\n\r\n    if (low > 0) {\r\n      return low - 1;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  private exponentialSearch({\r\n    index,\r\n    offset\r\n  }: {\r\n    index: number;\r\n    offset: number;\r\n  }) {\r\n    let interval = 1;\r\n\r\n    while (\r\n      index < this.itemCount &&\r\n      this.getSizeAndPositionForIndex(index).offset < offset\r\n    ) {\r\n      index += interval;\r\n      interval *= 2;\r\n    }\r\n\r\n    return this.binarySearch({\r\n      high: Math.min(index, this.itemCount - 1),\r\n      low: Math.floor(index / 2),\r\n      offset\r\n    });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}