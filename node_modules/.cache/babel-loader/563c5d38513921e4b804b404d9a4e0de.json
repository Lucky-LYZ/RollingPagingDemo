{"ast":null,"code":"import _defineProperty from \"D:\\\\MyProject\\\\scrollTable\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"D:\\\\MyProject\\\\scrollTable\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"D:\\\\MyProject\\\\scrollTable\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\MyProject\\\\scrollTable\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\MyProject\\\\scrollTable\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\MyProject\\\\scrollTable\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\MyProject\\\\scrollTable\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _objectSpread from \"D:\\\\MyProject\\\\scrollTable\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nvar _jsxFileName = \"D:\\\\MyProject\\\\scrollTable\\\\src\\\\components\\\\virtualList\\\\index.tsx\";\nimport * as React from \"react\";\nimport * as PropTypes from \"prop-types\";\nimport SizeAndPositionManager from \"./SizeAndPositionManager\";\nimport { ALIGNMENT, DIRECTION, SCROLL_CHANGE_REASON, marginProp, oppositeMarginProp, positionProp, scrollProp, sizeProp } from \"./constants\";\nexport { DIRECTION as ScrollDirection } from \"./constants\";\nvar STYLE_WRAPPER = {\n  overflow: \"auto\",\n  willChange: \"transform\",\n  WebkitOverflowScrolling: \"touch\"\n};\nvar STYLE_INNER = {\n  position: \"relative\",\n  width: \"100%\",\n  minHeight: \"100%\"\n};\nvar STYLE_ITEM = {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  width: \"100%\"\n};\n\nvar STYLE_STICKY_ITEM = _objectSpread({}, STYLE_ITEM, {\n  position: \"sticky\"\n});\n\nvar VirtualList =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(VirtualList, _React$PureComponent);\n\n  function VirtualList() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, VirtualList);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(VirtualList)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _this.itemSizeGetter = function (itemSize) {\n      return function (index) {\n        return _this.getSize(index, itemSize);\n      };\n    };\n\n    _this.sizeAndPositionManager = new SizeAndPositionManager({\n      itemCount: _this.props.itemCount,\n      itemSizeGetter: _this.itemSizeGetter(_this.props.itemSize),\n      estimatedItemSize: _this.getEstimatedItemSize()\n    });\n    _this.state = {\n      offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,\n      scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n    };\n    _this.rootNode = void 0;\n    _this.styleCache = {};\n\n    _this.getRef = function (node) {\n      _this.rootNode = node;\n    };\n\n    _this.handleScroll = function (event) {\n      var onScroll = _this.props.onScroll;\n\n      var offset = _this.getNodeOffset();\n\n      if (offset < 0 || _this.state.offset === offset || event.target !== _this.rootNode) {\n        return;\n      }\n\n      _this.setState({\n        offset: offset,\n        scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED\n      });\n\n      if (typeof onScroll === \"function\") {\n        onScroll(offset, event);\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(VirtualList, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props = this.props,\n          scrollOffset = _this$props.scrollOffset,\n          scrollToIndex = _this$props.scrollToIndex;\n      this.rootNode.addEventListener(\"scroll\", this.handleScroll, {\n        passive: true\n      });\n\n      if (scrollOffset != null) {\n        this.scrollTo(scrollOffset);\n      } else if (scrollToIndex != null) {\n        this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n      }\n    }\n  }, {\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(nextProps) {\n      var _this$props2 = this.props,\n          estimatedItemSize = _this$props2.estimatedItemSize,\n          itemCount = _this$props2.itemCount,\n          itemSize = _this$props2.itemSize,\n          scrollOffset = _this$props2.scrollOffset,\n          scrollToAlignment = _this$props2.scrollToAlignment,\n          scrollToIndex = _this$props2.scrollToIndex;\n      var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;\n      var itemPropsHaveChanged = nextProps.itemCount !== itemCount || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;\n\n      if (nextProps.itemSize !== itemSize) {\n        this.sizeAndPositionManager.updateConfig({\n          itemSizeGetter: this.itemSizeGetter(nextProps.itemSize)\n        });\n      }\n\n      if (nextProps.itemCount !== itemCount || nextProps.estimatedItemSize !== estimatedItemSize) {\n        this.sizeAndPositionManager.updateConfig({\n          itemCount: nextProps.itemCount,\n          estimatedItemSize: this.getEstimatedItemSize(nextProps)\n        });\n      }\n\n      if (itemPropsHaveChanged) {\n        this.recomputeSizes();\n      }\n\n      if (nextProps.scrollOffset !== scrollOffset) {\n        this.setState({\n          offset: nextProps.scrollOffset || 0,\n          scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n        });\n      } else if (typeof nextProps.scrollToIndex === \"number\" && (scrollPropsHaveChanged || itemPropsHaveChanged)) {\n        this.setState({\n          offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount),\n          scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n        });\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(_, prevState) {\n      var _this$state = this.state,\n          offset = _this$state.offset,\n          scrollChangeReason = _this$state.scrollChangeReason;\n\n      if (prevState.offset !== offset && scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {\n        this.scrollTo(offset);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.rootNode.removeEventListener(\"scroll\", this.handleScroll);\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(value) {\n      var _this$props$scrollDir = this.props.scrollDirection,\n          scrollDirection = _this$props$scrollDir === void 0 ? DIRECTION.VERTICAL : _this$props$scrollDir;\n      this.rootNode[scrollProp[scrollDirection]] = value;\n    }\n  }, {\n    key: \"getOffsetForIndex\",\n    value: function getOffsetForIndex(index) {\n      var scrollToAlignment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.scrollToAlignment;\n      var itemCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.props.itemCount;\n      var _this$props$scrollDir2 = this.props.scrollDirection,\n          scrollDirection = _this$props$scrollDir2 === void 0 ? DIRECTION.VERTICAL : _this$props$scrollDir2;\n\n      if (index < 0 || index >= itemCount) {\n        index = 0;\n      }\n\n      return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n        align: scrollToAlignment,\n        containerSize: this.props[sizeProp[scrollDirection]],\n        currentOffset: this.state && this.state.offset || 0,\n        targetIndex: index\n      });\n    }\n  }, {\n    key: \"recomputeSizes\",\n    value: function recomputeSizes() {\n      var startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this.styleCache = {};\n      this.sizeAndPositionManager.resetItem(startIndex);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props3 = this.props,\n          estimatedItemSize = _this$props3.estimatedItemSize,\n          height = _this$props3.height,\n          _this$props3$overscan = _this$props3.overscanCount,\n          overscanCount = _this$props3$overscan === void 0 ? 3 : _this$props3$overscan,\n          renderItem = _this$props3.renderItem,\n          itemCount = _this$props3.itemCount,\n          itemSize = _this$props3.itemSize,\n          onItemsRendered = _this$props3.onItemsRendered,\n          onScroll = _this$props3.onScroll,\n          _this$props3$scrollDi = _this$props3.scrollDirection,\n          scrollDirection = _this$props3$scrollDi === void 0 ? DIRECTION.VERTICAL : _this$props3$scrollDi,\n          scrollOffset = _this$props3.scrollOffset,\n          scrollToIndex = _this$props3.scrollToIndex,\n          scrollToAlignment = _this$props3.scrollToAlignment,\n          stickyIndices = _this$props3.stickyIndices,\n          style = _this$props3.style,\n          width = _this$props3.width,\n          props = _objectWithoutProperties(_this$props3, [\"estimatedItemSize\", \"height\", \"overscanCount\", \"renderItem\", \"itemCount\", \"itemSize\", \"onItemsRendered\", \"onScroll\", \"scrollDirection\", \"scrollOffset\", \"scrollToIndex\", \"scrollToAlignment\", \"stickyIndices\", \"style\", \"width\"]);\n\n      var offset = this.state.offset;\n\n      var _this$sizeAndPosition = this.sizeAndPositionManager.getVisibleRange({\n        containerSize: this.props[sizeProp[scrollDirection]] || 0,\n        offset: offset,\n        overscanCount: overscanCount\n      }),\n          start = _this$sizeAndPosition.start,\n          stop = _this$sizeAndPosition.stop;\n\n      var items = [];\n\n      var wrapperStyle = _objectSpread({}, STYLE_WRAPPER, {}, style, {\n        height: height,\n        width: width\n      });\n\n      var innerStyle = _objectSpread({}, STYLE_INNER, _defineProperty({}, sizeProp[scrollDirection], this.sizeAndPositionManager.getTotalSize()));\n\n      if (stickyIndices != null && stickyIndices.length !== 0) {\n        stickyIndices.forEach(function (index) {\n          return items.push(renderItem({\n            index: index,\n            style: _this2.getStyle(index, true)\n          }));\n        });\n\n        if (scrollDirection === DIRECTION.HORIZONTAL) {\n          innerStyle.display = \"flex\";\n        }\n      }\n\n      if (typeof start !== \"undefined\" && typeof stop !== \"undefined\") {\n        for (var index = start; index <= stop; index++) {\n          if (stickyIndices != null && stickyIndices.includes(index)) {\n            continue;\n          }\n\n          items.push(renderItem({\n            index: index,\n            style: this.getStyle(index, false)\n          }));\n        }\n\n        if (typeof onItemsRendered === \"function\") {\n          onItemsRendered({\n            startIndex: start,\n            stopIndex: stop\n          });\n        }\n      }\n\n      return React.createElement(\"div\", Object.assign({\n        ref: this.getRef\n      }, props, {\n        style: wrapperStyle,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 344\n        },\n        __self: this\n      }), React.createElement(\"div\", {\n        style: innerStyle,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 345\n        },\n        __self: this\n      }, items));\n    }\n  }, {\n    key: \"getNodeOffset\",\n    value: function getNodeOffset() {\n      var _this$props$scrollDir3 = this.props.scrollDirection,\n          scrollDirection = _this$props$scrollDir3 === void 0 ? DIRECTION.VERTICAL : _this$props$scrollDir3;\n      return this.rootNode[scrollProp[scrollDirection]];\n    }\n  }, {\n    key: \"getEstimatedItemSize\",\n    value: function getEstimatedItemSize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      return props.estimatedItemSize || typeof props.itemSize === \"number\" && props.itemSize || 50;\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize(index, itemSize) {\n      if (typeof itemSize === \"function\") {\n        return itemSize(index);\n      }\n\n      return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n    }\n  }, {\n    key: \"getStyle\",\n    value: function getStyle(index, sticky) {\n      var _objectSpread3, _objectSpread4;\n\n      var style = this.styleCache[index];\n\n      if (style) {\n        return style;\n      }\n\n      var _this$props$scrollDir4 = this.props.scrollDirection,\n          scrollDirection = _this$props$scrollDir4 === void 0 ? DIRECTION.VERTICAL : _this$props$scrollDir4;\n\n      var _this$sizeAndPosition2 = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),\n          size = _this$sizeAndPosition2.size,\n          offset = _this$sizeAndPosition2.offset;\n\n      return this.styleCache[index] = sticky ? _objectSpread({}, STYLE_STICKY_ITEM, (_objectSpread3 = {}, _defineProperty(_objectSpread3, sizeProp[scrollDirection], size), _defineProperty(_objectSpread3, marginProp[scrollDirection], offset), _defineProperty(_objectSpread3, oppositeMarginProp[scrollDirection], -(offset + size)), _defineProperty(_objectSpread3, \"zIndex\", 1), _objectSpread3)) : _objectSpread({}, STYLE_ITEM, (_objectSpread4 = {}, _defineProperty(_objectSpread4, sizeProp[scrollDirection], size), _defineProperty(_objectSpread4, positionProp[scrollDirection], offset), _objectSpread4));\n    }\n  }]);\n\n  return VirtualList;\n}(React.PureComponent);\n\nVirtualList.defaultProps = {\n  overscanCount: 3,\n  scrollDirection: DIRECTION.VERTICAL,\n  width: \"100%\"\n};\nVirtualList.propTypes = {\n  estimatedItemSize: PropTypes.number,\n  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n  itemCount: PropTypes.number.isRequired,\n  itemSize: PropTypes.oneOfType([PropTypes.number, PropTypes.array, PropTypes.func]).isRequired,\n  onScroll: PropTypes.func,\n  onItemsRendered: PropTypes.func,\n  overscanCount: PropTypes.number,\n  renderItem: PropTypes.func.isRequired,\n  scrollOffset: PropTypes.number,\n  scrollToIndex: PropTypes.number,\n  scrollToAlignment: PropTypes.oneOf([ALIGNMENT.AUTO, ALIGNMENT.START, ALIGNMENT.CENTER, ALIGNMENT.END]),\n  scrollDirection: PropTypes.oneOf([DIRECTION.HORIZONTAL, DIRECTION.VERTICAL]),\n  stickyIndices: PropTypes.arrayOf(PropTypes.number),\n  style: PropTypes.object,\n  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\n};\nexport { VirtualList as default };","map":{"version":3,"sources":["D:/MyProject/scrollTable/src/components/virtualList/index.tsx"],"names":["React","PropTypes","SizeAndPositionManager","ALIGNMENT","DIRECTION","SCROLL_CHANGE_REASON","marginProp","oppositeMarginProp","positionProp","scrollProp","sizeProp","ScrollDirection","STYLE_WRAPPER","overflow","willChange","WebkitOverflowScrolling","STYLE_INNER","position","width","minHeight","STYLE_ITEM","top","left","STYLE_STICKY_ITEM","VirtualList","itemSizeGetter","itemSize","index","getSize","sizeAndPositionManager","itemCount","props","estimatedItemSize","getEstimatedItemSize","state","offset","scrollOffset","scrollToIndex","getOffsetForIndex","scrollChangeReason","REQUESTED","rootNode","styleCache","getRef","node","handleScroll","event","onScroll","getNodeOffset","target","setState","OBSERVED","addEventListener","passive","scrollTo","nextProps","scrollToAlignment","scrollPropsHaveChanged","itemPropsHaveChanged","updateConfig","recomputeSizes","_","prevState","removeEventListener","value","scrollDirection","VERTICAL","getUpdatedOffsetForIndex","align","containerSize","currentOffset","targetIndex","startIndex","resetItem","height","overscanCount","renderItem","onItemsRendered","stickyIndices","style","getVisibleRange","start","stop","items","wrapperStyle","innerStyle","getTotalSize","length","forEach","push","getStyle","HORIZONTAL","display","includes","stopIndex","Array","isArray","sticky","getSizeAndPositionForIndex","size","PureComponent","defaultProps","propTypes","number","oneOfType","string","isRequired","array","func","oneOf","AUTO","START","CENTER","END","arrayOf","object"],"mappings":"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","sourcesContent":["import * as React from \"react\";\r\nimport * as PropTypes from \"prop-types\";\r\nimport SizeAndPositionManager, { ItemSize } from \"./SizeAndPositionManager\";\r\nimport {\r\n  ALIGNMENT,\r\n  DIRECTION,\r\n  SCROLL_CHANGE_REASON,\r\n  marginProp,\r\n  oppositeMarginProp,\r\n  positionProp,\r\n  scrollProp,\r\n  sizeProp\r\n} from \"./constants\";\r\n\r\nexport { DIRECTION as ScrollDirection } from \"./constants\";\r\nexport type ItemPosition = \"absolute\" | \"sticky\";\r\n\r\nexport interface ItemStyle {\r\n  position: ItemPosition;\r\n  top?: number;\r\n  left: number;\r\n  width: string | number;\r\n  height?: number;\r\n  marginTop?: number;\r\n  marginLeft?: number;\r\n  marginRight?: number;\r\n  marginBottom?: number;\r\n  zIndex?: number;\r\n}\r\n\r\ninterface StyleCache {\r\n  [id: number]: ItemStyle;\r\n}\r\n\r\nexport interface ItemInfo {\r\n  index: number;\r\n  style: ItemStyle;\r\n}\r\n\r\nexport interface RenderedRows {\r\n  startIndex: number;\r\n  stopIndex: number;\r\n}\r\n\r\nexport interface Props {\r\n  className?: string;\r\n  estimatedItemSize?: number;\r\n  height: number | string;\r\n  itemCount: number;\r\n  itemSize: ItemSize;\r\n  overscanCount?: number;\r\n  scrollOffset?: number;\r\n  scrollToIndex?: number;\r\n  scrollToAlignment?: ALIGNMENT;\r\n  scrollDirection?: DIRECTION;\r\n  stickyIndices?: number[];\r\n  style?: React.CSSProperties;\r\n  width?: number | string;\r\n  onItemsRendered?({ startIndex, stopIndex }: RenderedRows): void;\r\n  onScroll?(offset: number, event: UIEvent): void;\r\n  renderItem(itemInfo: ItemInfo): React.ReactNode;\r\n}\r\n\r\nexport interface State {\r\n  offset: number;\r\n  scrollChangeReason: SCROLL_CHANGE_REASON;\r\n}\r\n\r\nconst STYLE_WRAPPER: React.CSSProperties = {\r\n  overflow: \"auto\",\r\n  willChange: \"transform\",\r\n  WebkitOverflowScrolling: \"touch\"\r\n};\r\n\r\nconst STYLE_INNER: React.CSSProperties = {\r\n  position: \"relative\",\r\n  width: \"100%\",\r\n  minHeight: \"100%\"\r\n};\r\n\r\nconst STYLE_ITEM: {\r\n  position: ItemStyle[\"position\"];\r\n  top: ItemStyle[\"top\"];\r\n  left: ItemStyle[\"left\"];\r\n  width: ItemStyle[\"width\"];\r\n} = {\r\n  position: \"absolute\" as ItemPosition,\r\n  top: 0,\r\n  left: 0,\r\n  width: \"100%\"\r\n};\r\n\r\nconst STYLE_STICKY_ITEM = {\r\n  ...STYLE_ITEM,\r\n  position: \"sticky\" as ItemPosition\r\n};\r\n\r\nexport default class VirtualList extends React.PureComponent<Props, State> {\r\n  static defaultProps = {\r\n    overscanCount: 3,\r\n    scrollDirection: DIRECTION.VERTICAL,\r\n    width: \"100%\"\r\n  };\r\n\r\n  static propTypes = {\r\n    estimatedItemSize: PropTypes.number,\r\n    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\r\n      .isRequired,\r\n    itemCount: PropTypes.number.isRequired,\r\n    itemSize: PropTypes.oneOfType([\r\n      PropTypes.number,\r\n      PropTypes.array,\r\n      PropTypes.func\r\n    ]).isRequired,\r\n    onScroll: PropTypes.func,\r\n    onItemsRendered: PropTypes.func,\r\n    overscanCount: PropTypes.number,\r\n    renderItem: PropTypes.func.isRequired,\r\n    scrollOffset: PropTypes.number,\r\n    scrollToIndex: PropTypes.number,\r\n    scrollToAlignment: PropTypes.oneOf([\r\n      ALIGNMENT.AUTO,\r\n      ALIGNMENT.START,\r\n      ALIGNMENT.CENTER,\r\n      ALIGNMENT.END\r\n    ]),\r\n    scrollDirection: PropTypes.oneOf([\r\n      DIRECTION.HORIZONTAL,\r\n      DIRECTION.VERTICAL\r\n    ]),\r\n    stickyIndices: PropTypes.arrayOf(PropTypes.number),\r\n    style: PropTypes.object,\r\n    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\r\n  };\r\n\r\n  itemSizeGetter = (itemSize: Props[\"itemSize\"]) => {\r\n    return index => this.getSize(index, itemSize);\r\n  };\r\n\r\n  sizeAndPositionManager = new SizeAndPositionManager({\r\n    itemCount: this.props.itemCount,\r\n    itemSizeGetter: this.itemSizeGetter(this.props.itemSize),\r\n    estimatedItemSize: this.getEstimatedItemSize()\r\n  });\r\n\r\n  readonly state: State = {\r\n    offset:\r\n      this.props.scrollOffset ||\r\n      (this.props.scrollToIndex != null &&\r\n        this.getOffsetForIndex(this.props.scrollToIndex)) ||\r\n      0,\r\n    scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\r\n  };\r\n\r\n  private rootNode: HTMLElement;\r\n\r\n  private styleCache: StyleCache = {};\r\n\r\n  componentDidMount() {\r\n    const { scrollOffset, scrollToIndex } = this.props;\r\n    this.rootNode.addEventListener(\"scroll\", this.handleScroll, {\r\n      passive: true\r\n    });\r\n\r\n    if (scrollOffset != null) {\r\n      this.scrollTo(scrollOffset);\r\n    } else if (scrollToIndex != null) {\r\n      this.scrollTo(this.getOffsetForIndex(scrollToIndex));\r\n    }\r\n  }\r\n\r\n  UNSAFE_componentWillReceiveProps(nextProps: Props) {\r\n    const {\r\n      estimatedItemSize,\r\n      itemCount,\r\n      itemSize,\r\n      scrollOffset,\r\n      scrollToAlignment,\r\n      scrollToIndex\r\n    } = this.props;\r\n    const scrollPropsHaveChanged =\r\n      nextProps.scrollToIndex !== scrollToIndex ||\r\n      nextProps.scrollToAlignment !== scrollToAlignment;\r\n    const itemPropsHaveChanged =\r\n      nextProps.itemCount !== itemCount ||\r\n      nextProps.itemSize !== itemSize ||\r\n      nextProps.estimatedItemSize !== estimatedItemSize;\r\n\r\n    if (nextProps.itemSize !== itemSize) {\r\n      this.sizeAndPositionManager.updateConfig({\r\n        itemSizeGetter: this.itemSizeGetter(nextProps.itemSize)\r\n      });\r\n    }\r\n\r\n    if (\r\n      nextProps.itemCount !== itemCount ||\r\n      nextProps.estimatedItemSize !== estimatedItemSize\r\n    ) {\r\n      this.sizeAndPositionManager.updateConfig({\r\n        itemCount: nextProps.itemCount,\r\n        estimatedItemSize: this.getEstimatedItemSize(nextProps)\r\n      });\r\n    }\r\n\r\n    if (itemPropsHaveChanged) {\r\n      this.recomputeSizes();\r\n    }\r\n\r\n    if (nextProps.scrollOffset !== scrollOffset) {\r\n      this.setState({\r\n        offset: nextProps.scrollOffset || 0,\r\n        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\r\n      });\r\n    } else if (\r\n      typeof nextProps.scrollToIndex === \"number\" &&\r\n      (scrollPropsHaveChanged || itemPropsHaveChanged)\r\n    ) {\r\n      this.setState({\r\n        offset: this.getOffsetForIndex(\r\n          nextProps.scrollToIndex,\r\n          nextProps.scrollToAlignment,\r\n          nextProps.itemCount\r\n        ),\r\n        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\r\n      });\r\n    }\r\n  }\r\n\r\n  componentDidUpdate(_: Props, prevState: State) {\r\n    const { offset, scrollChangeReason } = this.state;\r\n\r\n    if (\r\n      prevState.offset !== offset &&\r\n      scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED\r\n    ) {\r\n      this.scrollTo(offset);\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.rootNode.removeEventListener(\"scroll\", this.handleScroll);\r\n  }\r\n\r\n  scrollTo(value: number) {\r\n    const { scrollDirection = DIRECTION.VERTICAL } = this.props;\r\n\r\n    this.rootNode[scrollProp[scrollDirection]] = value;\r\n  }\r\n\r\n  getOffsetForIndex(\r\n    index: number,\r\n    scrollToAlignment = this.props.scrollToAlignment,\r\n    itemCount: number = this.props.itemCount\r\n  ): number {\r\n    const { scrollDirection = DIRECTION.VERTICAL } = this.props;\r\n\r\n    if (index < 0 || index >= itemCount) {\r\n      index = 0;\r\n    }\r\n\r\n    return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\r\n      align: scrollToAlignment,\r\n      containerSize: this.props[sizeProp[scrollDirection]],\r\n      currentOffset: (this.state && this.state.offset) || 0,\r\n      targetIndex: index\r\n    });\r\n  }\r\n\r\n  recomputeSizes(startIndex = 0) {\r\n    this.styleCache = {};\r\n    this.sizeAndPositionManager.resetItem(startIndex);\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      estimatedItemSize,\r\n      height,\r\n      overscanCount = 3,\r\n      renderItem,\r\n      itemCount,\r\n      itemSize,\r\n      onItemsRendered,\r\n      onScroll,\r\n      scrollDirection = DIRECTION.VERTICAL,\r\n      scrollOffset,\r\n      scrollToIndex,\r\n      scrollToAlignment,\r\n      stickyIndices,\r\n      style,\r\n      width,\r\n      ...props\r\n    } = this.props;\r\n    const { offset } = this.state;\r\n    const { start, stop } = this.sizeAndPositionManager.getVisibleRange({\r\n      containerSize: this.props[sizeProp[scrollDirection]] || 0,\r\n      offset,\r\n      overscanCount\r\n    });\r\n    const items: React.ReactNode[] = [];\r\n    const wrapperStyle = { ...STYLE_WRAPPER, ...style, height, width };\r\n    const innerStyle = {\r\n      ...STYLE_INNER,\r\n      [sizeProp[scrollDirection]]: this.sizeAndPositionManager.getTotalSize()\r\n    };\r\n\r\n    if (stickyIndices != null && stickyIndices.length !== 0) {\r\n      stickyIndices.forEach((index: number) =>\r\n        items.push(\r\n          renderItem({\r\n            index,\r\n            style: this.getStyle(index, true)\r\n          })\r\n        )\r\n      );\r\n\r\n      if (scrollDirection === DIRECTION.HORIZONTAL) {\r\n        innerStyle.display = \"flex\";\r\n      }\r\n    }\r\n\r\n    if (typeof start !== \"undefined\" && typeof stop !== \"undefined\") {\r\n      for (let index = start; index <= stop; index++) {\r\n        if (stickyIndices != null && stickyIndices.includes(index)) {\r\n          continue;\r\n        }\r\n\r\n        items.push(\r\n          renderItem({\r\n            index,\r\n            style: this.getStyle(index, false)\r\n          })\r\n        );\r\n      }\r\n\r\n      if (typeof onItemsRendered === \"function\") {\r\n        onItemsRendered({\r\n          startIndex: start,\r\n          stopIndex: stop\r\n        });\r\n      }\r\n    }\r\n\r\n    return (\r\n      <div ref={this.getRef} {...props} style={wrapperStyle}>\r\n        <div style={innerStyle}>{items}</div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  private getRef = (node: HTMLDivElement): void => {\r\n    this.rootNode = node;\r\n  };\r\n\r\n  private handleScroll = (event: UIEvent) => {\r\n    const { onScroll } = this.props;\r\n    const offset = this.getNodeOffset();\r\n\r\n    if (\r\n      offset < 0 ||\r\n      this.state.offset === offset ||\r\n      event.target !== this.rootNode\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      offset,\r\n      scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED\r\n    });\r\n\r\n    if (typeof onScroll === \"function\") {\r\n      onScroll(offset, event);\r\n    }\r\n  };\r\n\r\n  private getNodeOffset() {\r\n    const { scrollDirection = DIRECTION.VERTICAL } = this.props;\r\n\r\n    return this.rootNode[scrollProp[scrollDirection]];\r\n  }\r\n\r\n  private getEstimatedItemSize(props = this.props) {\r\n    return (\r\n      props.estimatedItemSize ||\r\n      (typeof props.itemSize === \"number\" && props.itemSize) ||\r\n      50\r\n    );\r\n  }\r\n\r\n  private getSize(index: number, itemSize) {\r\n    if (typeof itemSize === \"function\") {\r\n      return itemSize(index);\r\n    }\r\n\r\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\r\n  }\r\n\r\n  private getStyle(index: number, sticky: boolean) {\r\n    const style = this.styleCache[index];\r\n\r\n    if (style) {\r\n      return style;\r\n    }\r\n\r\n    const { scrollDirection = DIRECTION.VERTICAL } = this.props;\r\n    const {\r\n      size,\r\n      offset\r\n    } = this.sizeAndPositionManager.getSizeAndPositionForIndex(index);\r\n\r\n    return (this.styleCache[index] = sticky\r\n      ? {\r\n          ...STYLE_STICKY_ITEM,\r\n          [sizeProp[scrollDirection]]: size,\r\n          [marginProp[scrollDirection]]: offset,\r\n          [oppositeMarginProp[scrollDirection]]: -(offset + size),\r\n          zIndex: 1\r\n        }\r\n      : {\r\n          ...STYLE_ITEM,\r\n          [sizeProp[scrollDirection]]: size,\r\n          [positionProp[scrollDirection]]: offset\r\n        });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}